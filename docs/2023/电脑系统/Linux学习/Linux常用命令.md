# Linux常用命令

> 2024年7月3日17:43:39

## ll查看文件

```sh
ll
```

"ll"是列表显示文件和目录的Linux命令，它实际上是"ls -l"的别名。"ls -l"命令在显示文件和目录时，会显示详细信息，包括权限，所有者，大小, 和最后修改时间等。

"ls"是Linux下的列出目录内容的命令。只输入"ls"会列出当前目录下的文件和文件夹名称，不包括隐藏文件和详细信息。

## unzip解压缩

> unzip这个包通常默认安装

```sh
unzip test.zip
```

* 或强制覆盖(不推荐，建议先删后增)

```sh
unzip -o test.zip
```

## wget发起请求

> 如果部署的服务有一个功能性的get接口,这时就需要通过一个脚本来调用了

* 注：wget本来是用来下载文件的，但也可以去触发get接口
* 注：wget可能没有安装,出现`wget: command not found`就说明需要先安装wget
* 注：在服务器上也是使用`127.0.0.1`域名，因为是在服务器上调用的，自然是本地，而且这样更通用。

假如有以下接口：

```http
GET http://127.0.0.1:8848/myService/api/xxx?paramm=x01
```

可以输入这样的命令来调用

```sh
wget http://127.0.0.1:8848/myService/api/xxx?paramm=x01
```

## 直接调用sh脚本

* 比如在当前文件夹下有一个叫`xxx.sh`的sh脚本
* 直接输入文件路径就自动调用了

```sh
./xxx.sh
```

## telnet检查端口(通用)

> 该命令在window上也能用

* telnet使用户在本地计算机上执行远程计算机上的命令，但现在已经更安全的SSH协议淘汰了。
* 不过我们可以用他来检查对应的端口是否畅通

```sh
telnet [选项] [主机] [端口] 
```

* 一般是这样：

```sh
telnet 192.168.1.1 8848
```

* 注意：端口号与ip之间空格分割
* 输完以后回车就行，如果弹出一个全黑的窗口就说明执行成功，把窗口关了就好。输入【q+回车】退出也行。

## tail -200f查看日志

```sh
tail -200f xxx.log
```

`tail -200f` 命令在Linux中用于监视文件的变化。

`tail` 命令的作用是输出文件最后部分内容，`-200` 选项表示显示文件的最后200行，`f` 选项表示监视文件的变化，即当文件新添加内容时，这些内容会被直接输出到屏幕上。

所以 `tail -200f` 命令的作用就是显示文件最后200行，并监视文件后续的变化。通常用于动态查看日志文件等。

## tail -n转存日志

* 比如将最后的8000行生成为另一个文件

```sh
tail -n 8000 xxx.log > newfile.log
```

这个命令会将日志文件xxx.log的最后80000行提取出来并创建一个新的日志文件newfile.log。如果newfile.log文件已经存在，则该命令将覆盖原有内容。如果你不想覆盖而是想追加到已有的文件，就使用>>而不是>:

```shell
tail -n 8000 xxx.log >> existingfile.log
```

## chmod设置文件权限

* 比如让某个文件夹所有用户都可读写

```sh
chmod 777 文件夹路径
```

* `777` 权限意味着用户（文件所有者）、组用户以及其他用户都拥有读、写和执行的权限。

### 777 编码的含义

数字 777 是一个三位数，每一位分别代表用户（user）、组（group）和其他（others）的权限。

- 第一个 7：代表用户（文件所有者）的权限。7 是由 4（读） + 2（写） + 1（执行）得到的。
- 第二个 7：代表组用户的权限。同样，7 表示组用户也拥有读、写和执行的权限。
- 第三个 7：代表其他用户的权限。7 表明其他用户同样拥有读、写和执行的权限。

777 对应的字母表示法是 `rwxrwxrwx`，其中：

- 前三位 `rwx` 代表用户的权限。
- 中间三位 `rwx` 代表组用户的权限。
- 最后三位 `rwx` 代表其他用户的权限。

### 其他常见权限编码

- **644**：对应字母表示法 `rw-r--r--`。用户拥有读和写权限（4 + 2 = 6），组用户和其他用户只有读权限（4）。
- **755**：对应字母表示法 `rwxr-xr-x`。用户拥有读、写和执行权限（4 + 2 + 1 = 7），组用户和其他用户拥有读和执行权限（4 + 1 = 5）。

## ps -ef查找java进程

`ps -ef|grep java` 是一个在类 Unix 系统（像 Linux、macOS 等）里常用的命令组合，其作用是查找正在运行的 Java 进程。下面为你详细解释：

**命令拆解**

1. **`ps -ef`**：
    - `ps` 是用于查看当前系统中进程状态的命令。
    - `-e` 表示显示所有进程，涵盖了所有用户的进程。
    - `-f` 表示以全格式输出，会展示更多进程相关的信息，像进程的 UID（用户 ID）、PID（进程 ID）、PPID（父进程 ID）、C（CPU 使用率）、STIME（启动时间）、TTY（终端设备）、TIME（CPU 占用时间）以及 CMD（启动进程的命令）等。

2. **`|`**：
    - 这是管道符号，其功能是把前一个命令的输出当作后一个命令的输入。

3. **`grep java`**：
    - `grep` 是一个用于文本搜索的命令。
    - `java` 是搜索的关键字，此命令会在 `ps -ef` 输出的结果里查找包含 `java` 的行。

**示例输出**

运行 `ps -ef|grep java` 后，输出可能如下：
```plaintext
user      1234     1  0 10:00 ?        00:00:05 java -jar myapp.jar
user      5678  1234  0 10:01 ?        00:00:02 java -cp lib/* com.example.Main
```
在这个输出中，每一行都代表一个正在运行的 Java 进程，包含了进程的各种信息。

借助 `ps -ef|grep java` 命令，你能够快速找出系统中正在运行的 Java 进程，并且获取这些进程的详细信息。 

## kill -9 终止进程

比如在前面查出来的`ps -ef|grep java`

```sh
kill -9 5678
```

## nohup启动Jar服务

> 2025-12-01 10:46:59，启动服务与停止服务

* 这段命令是**在Linux/Unix系统中后台启动一个Java应用程序**的完整指令，结合了`nohup`、Java虚拟机（JVM）参数、应用启动参数和日志重定向。
* 核心目的：**脱离终端后台运行Java程序，且终端关闭后进程不终止，同时将所有输出写入日志文件**。

```bash
nohup java -server   -XX:+HeapDumpOnOutOfMemoryError   -Xms256M -Xmx256M   -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M   -XX:MaxDirectMemorySize=256M   -XX:+AlwaysPreTouch   -jar 我的jar包.jar   --spring.profiles.active=jg   > 我的jar.log 2>&1 &
```

* 通过nohup启动服务，使用如下命令查找进程，查到进程ID后可以通过`kill -9`终止

```bash
ps -ef | grep java | grep 我的jar包.jar | grep -v grep
```

### 逐部分详细解释

#### 1. `nohup`：脱离终端的后台运行
- `nohup` 是Linux/Unix命令，全称“no hang up”（不挂起）。
- 作用：即使关闭当前终端（如SSH连接断开），启动的进程也不会被终止，会继续在后台运行。
- 注意：`nohup` 默认会把输出写入 `nohup.out` 文件，这里通过日志重定向覆盖了默认行为。

#### 2. Java虚拟机（JVM）核心参数
`java` 命令后的 `-server`、`-XX:...`、`-Xms/-Xmx` 都是JVM启动参数，用于配置虚拟机运行环境：

| 参数 | 含义 |
|------|------|
| `-server` | 指定JVM以“服务器模式”运行（针对服务端场景优化，启动慢但运行效率高，64位JDK默认启用） |
| `-XX:+HeapDumpOnOutOfMemoryError` | 当JVM发生**内存溢出（OOM）** 时，自动生成堆转储文件（heap dump），用于事后分析OOM原因 |
| `-Xms256M` | JVM**初始堆内存**设置为256MB（堆是Java对象存储的核心区域） |
| `-Xmx256M` | JVM**最大堆内存**设置为256MB（初始=最大，避免运行时动态调整堆大小导致性能波动） |
| `-XX:MetaspaceSize=256M` | 元空间（Metaspace）**初始大小**256MB（元空间替代了传统的永久代，存储类元数据、常量池等） |
| `-XX:MaxMetaspaceSize=256M` | 元空间**最大大小**256MB（限制元空间占用，防止耗尽系统内存） |
| `-XX:MaxDirectMemorySize=256M` | 直接内存（堆外内存）**最大大小**256MB（NIO等场景会用到堆外内存，需单独限制） |
| `-XX:+AlwaysPreTouch` | JVM启动时**提前分配并初始化所有指定的内存**（而非运行时懒加载），避免运行时内存分配的性能抖动，适合生产环境 |

#### 3. 应用启动参数
| 参数 | 含义 |
|------|------|
| `-jar 我的jar包.jar` | 指定运行的Java可执行JAR包（`我的jar`是应用名，2.0.1-SNAPSHOT是版本，SNAPSHOT表示快照版） |
| `--spring.profiles.active=jingu` | Spring Boot的环境配置参数，指定激活“jingu”环境的配置（对应项目中`application-jingu.yml/properties`配置文件） |

#### 4. 日志重定向 & 后台运行
| 部分 | 含义 |
|------|------|
| `> 我的jar.log` | 将程序的**标准输出（stdout，正常日志）** 重定向到`我的jar.log`文件（覆盖原有内容） |
| `2>&1` | 将**标准错误（stderr，错误日志）** 重定向到和标准输出相同的位置（即`我的jar.log`），实现“正常日志+错误日志”合并记录 |
| `&` | 让命令在**后台运行**（终端可继续执行其他操作，不会被进程阻塞） |

## rm -rf删除文件

```bash
rm -rf 我的jar包.jar
```

`rm -rf` 是 Linux/Unix 系统中 `rm` 命令的组合参数用法，专门用于**强制、递归删除文件/目录**，下面拆解每个部分的含义：

### 核心参数拆解
| 部分 | 含义 | 作用细节 |
|------|------|----------|
| `rm` | remove 的缩写 | 基础命令，用于删除文件/目录（默认只能删文件，删目录需加参数） |
| `-r` | recursive（递归） | 递归删除，**主要用于删除目录**：会遍历目录下所有子文件、子目录并全部删除；<br>如果删除的是文件（如你的JAR包），`-r` 无实际作用，但加了也不会报错 |
| `-f` | force（强制） | 强制删除，跳过所有确认提示、忽略“文件不存在”的错误、无视文件只读权限；<br>默认 `rm` 删除只读文件时会提示确认，加 `-f` 直接删除，无任何交互 |


### 高危提醒（必看）
`rm -rf` 是 Linux 中**最危险的命令之一**，一旦执行无法恢复（无回收站），需特别注意：
1. 绝对避免执行 `rm -rf /`（删除系统根目录，直接导致系统崩溃）；
2. 删文件/目录前，先用 `ls` 确认路径：比如删JAR包前先执行 `ls -l 我的jar包.jar`，确认文件存在且是目标文件；
3. 生产环境删除操作建议加 `i` 交互确认（即使加 `-f`，`-i` 优先级更高）：`rm -rfi 目标`，删除前会逐个确认，防止误删。

