# **网关加解密处理流程**

## **一、客户端发起请求** 

客户端在请求前，会设置几个参数：

1. Authorization: Token，用于会话校验

2. user-identity：jtiValue，用于会话校验

3. Stime：当前时间戳

4. Nonce: 通过“Stime+UUID”使用SM3签名算法，来生成一个“仅一次有效的随机字符串”，用于重放校验。

5. Key: SM4对称密钥(使用SM2非对称加密算法加密)

6. Lv: 偏移量，这里是为了给使用AES加密时所用，平时为空。

7. KeyTp: 加密方法枚举，比如使用了Sm4+SM2加密，然后这里传值为”0”，表示使用了Sm4+SM2加密。

8. Sign: 使用SM3签名算法，通过“Stime+Nonce+原报文”，生成的摘要字符串。

9. Body: 使用SM4对称加密之后的报文，如果是POST请求，则加密整个请求体，将请求体从JSON变成String，如果是GET请求，则不加密URL参数中的Key，只加密key对应的value参数。

## **二、网关请求处理流程** 

其中网关在收到客户端的请求时，会从请求头中读取时间戳(Stime)、Nonce、Sign、Authorization、User-Identity、对称秘钥Key、加密方案KeyTp，以及请求URI、请求IP，并将这些参数存入服务器的共享线程变量中。

### **2.1、重放攻击校验**

重放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。

而为了防止重放攻击，会采用基于timestamp和nonce的防止重放攻击方案(参考博客：[基于timestamp和nonce的防止重放攻击方案](https://blog.csdn.net/koastal/article/details/53456696))。在请求传入时，会先经过重放攻击校验。

这里的请求在从客户端发起时，会通过“当前时间戳+UUID”来生成一个“仅一次有效的随机字符串”(nonce，使用SM3签名算法生成)，并将“时间戳”(timestamp)与“随机字符串”(nonce)放入请求头中，以供网关校验。

而网关在收到请求后，先从请求头中获取“时间戳”与“随机字符串”，接下来进行如下判定：

1. 如果“当前生成的时间戳”减去“请求头中的时间戳”的差值大于60s，则判定为重放请求，拒绝响应。

2. 如果“时间戳”的时间在60s以内，则以“请求头的nonce”为key，从服务器Redis进行读取Value，如果读取结果为空，就说明这是服务器第一次收到该请求，则将nonce保存在Redis中(并将存活时间设为60s)，并校验通过。而如果该nonce对应的value不为空，就说明这是重放攻击，需要进行拦截。

这一步通过后，就是通过客户端的ip地址来进行黑名单校验。

### **2.2、黑白名单校验**

这里获取客户端的ip地址来与服务器Redis的黑名单列表进行比对，如果在黑名单中就判定为非法请求，进行拦截。如果不在黑名单中就放行。

### **2.3、校验限流**

这里主要是通过读取请求地址的URL，以及令牌桶算法来判断是否进行鉴权校验限流。

接着判定该URL是否处于限流状态：服务器会根据每个请求的URL作为Key从ConcurrentHashMap中读取剩余令牌数量，如果没有该URL的键值对，就说明这是服务器第一次收到该URL的访问，则基于该URL建立一个新的令牌桶(容量为10，每秒生成10个令牌)。如果存在，则查看剩余令牌是否大于0，如果大于0则不处于限流状态，正常放行。

如果该请求的剩余令牌数量为0，则该URL处于限流状态，从这里直接返回请求到客户端。

### **2.4、校验用户会话**

通过从请求头获取User-Identity、Authorization的值来校验用户的会话，校验有以下几种情况：

1. Authorization为空，该用户未登录，返回“用户未登录”的代码(40904)

2. Authorization不为空，从获取redis用户信息，若用户信息为空则用户会话已失效，返回“会话过期”的代码(40902)。

3. Authorization不为空，且从获取redis用户信息不为空，则说明会话有效，校验通过，给予放行。

### **2.5、加密开关为开则进行解密**

这里的方案：对称加密的密钥，使用非对称加密进行传输。

这里判断服务器是否开启了加密。

如果未开启加密，则跳过解密报文的部分，直接通过请求方法的不同对报文进行验签。

如果开启了加密，则从请求头中获取密钥（对称密钥）以及加密方案KeyTp，如果密钥或加密方案为空，返回非法参数拒绝响应。

如果密钥和加密方案不为空，则根据请求方法的不同(POST或GET)，进行不同的解密：

POST请求：通过服务器的SM2私钥对该SM4对称密钥进行解密，再用解密后的对称密钥，以及请求头中的加密方式(keyTp)，来解密请求体的报文。如果解密失败则抛出异常，解密成功则进行摘要验证，通过“nonce+ Stime+解密后的原报文”生成一个内容摘要（sign），并与请求头中的sign进行比对。如果sign不一致则说明报文被篡改过，则判断为无效报文，拒绝响应。如果sign一致就给予放行。

GET请求：其它流程与POST处理一致，只是报文从请求体变成URL的参数。

其中URL参数中的Key是不加密的，服务器会依次获取每个key对应的value进行解密。

## **三、网关响应处理流程** 

各接口的返回值也要经过网关处理。

### **3.1 加签**

在接口进行响应时，先通过SM3签名算法对响应内容(整个RestfulResponse)生成摘要(sign)，并写入到响应头中。

### **3.2 对data数据域进行加密**

同时，**如果加密开关已经打开**，将请求时收到的key写入返回报文的key。然后再通过SM4对称密钥对报文中的data数据域进行加密处理，并将密文替换报文中的data域。

### **3.3 写入时间戳并响应**

接着获取当前时间，写入返回报文的stime。

至此，返回报文的key和加密报文(开启加密的情况)、stime、报文摘要都已写入，正式将报文传给客户端。

## **四、客户端处理响应报文** 

### **4.1、解密报文**

客户端在接到响应内容时，先会获取响应头中的密钥Key。

如果密钥为空，说明没有进行加密，则跳转到下一步验证报文是否篡改。

如果密钥不为空，则使用**本地保存**的对称密钥对报文(RestfulResponse格式)中的data部分进行解密，解密成功后将解密出来的数据重写入data，并跳转到下一步。

### **4.2、验签**

走到这一步要么加密开关没有打开，要么加密的报文解密成功。

客户端在这一步获取响应头中的摘要(sign)并进行验证，即使用“解密后的报文”(整个RestfulResponse)重新生成sign，并与服务器传的sign进行比对。

如果比对结果不一致，则说明报文被篡改过，则判断为无效报文，重写报文内容为“报文被非法篡改”。

如果比对结果一致，则正常显示。 